// Header.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import Header from '../header/Header'; // Убедитесь, что путь к файлу Header.tsx правильный
import type { CartItem } from '../../types/CartBagItem'; // Убедитесь, что путь к типу правильный
import emptyCartImage from '../../assets/cart_empty.png'; // Убедитесь, что путь к изображению правильный
import CartBag from '../cardbag/CartBag'; // Убедитесь, что путь к компоненту CartBag правильный

// Мок для CartBag, чтобы не рендерить его реальную реализацию в тестах Header
vi.mock('../cardbag/CartBag', () => ({
  default: ({ items, total }: { items: CartItem[]; total: number }) => (
    <div data-testid="mock-cart-bag">
      Mock CartBag: {items.length} items, Total: ${total}
    </div>
  ),
}));

// Мок для изображения, чтобы тесты не зависели от реального файла
vi.mock('../../assets/cart_empty.png', () => ({
  default: 'mocked-cart-empty-image-path.png',
}));

// Пример фиктивного типа CartItem, если не импортируется из другого места
// type CartItem = {
//   id: number;
//   name: string;
//   price: number;
//   image: string;
//   quantity: number;
// };

// Фиктивные данные для тестов
const mockCartItem1: CartItem = {
  id: 1,
  name: 'Test Product 1',
  price: 100,
  image: 'https://example.com/test1.jpg',
  quantity: 2,
};

const mockCartItem2: CartItem = {
  id: 2,
  name: 'Test Product 2',
  price: 50,
  image: 'https://example.com/test2.jpg',
  quantity: 1,
};

const mockCartItems: CartItem[] = [mockCartItem1, mockCartItem2];
const mockTotalCost = 250; // (100 * 2) + (50 * 1)

describe('Header', () => {
  const mockUpdateCartItemQuantity = vi.fn();
  const mockRemoveCartItem = vi.fn();

  // Вспомогательная функция для рендера компонента с нужными пропсами
  const renderHeader = (cartItems: CartItem[] = [], totalItems: number = 0, totalCost: number = 0) => {
    render(
      <Header
        cartItems={cartItems}
        updateCartItemQuantity={mockUpdateCartItemQuantity}
        removeCartItem={mockRemoveCartItem}
      />
    );
  };

  beforeEach(() => {
    // Очищаем мок-функции перед каждым тестом
    vi.clearAllMocks();
  });

  it('renders the site title correctly', () => {
    renderHeader();

    // Проверяем, что заголовок сайта отображается
    expect(screen.getByText('Vegetable')).toBeInTheDocument();
    expect(screen.getByText('SHOP')).toBeInTheDocument();
  });

  it('displays the correct number of items and total cost in the cart button badge when items are present', () => {
    renderHeader(mockCartItems, mockCartItems.length, mockTotalCost);

    // Проверяем, что бейдж с количеством товаров отображается
    expect(screen.getByText(mockCartItems.length.toString())).toBeInTheDocument(); // 3 items (2 + 1)

    // Проверяем, что на кнопке корзины есть иконка
    expect(screen.getByRole('button')).toContainElement(screen.getByIconName('cart-shopping')); // getByIconName может потребовать дополнительной настройки
    // Альтернатива: проверить, что кнопка существует и содержит текст/иконку
    expect(screen.getByRole('button', { name: /card/i })).toBeInTheDocument(); // Проверяем кнопку по тексту "Card"
  });

  it('does not display the cart items badge when the cart is empty', () => {
    renderHeader([], 0, 0);

    // Проверяем, что бейдж с количеством НЕ отображается
    expect(screen.queryByText('0')).not.toBeInTheDocument(); // Нет бейджа с 0
    // Проверяем, что элемент бейджа (Badge) НЕ присутствует в DOM
    expect(screen.queryByTestId('cart-badge')).not.toBeInTheDocument(); // Предполагаем, что бейдж можно идентифицировать по testId, если добавить
    // В текущем коде бейдж рендерится только если totalItems > 0, так что queryByText('0') подходит.
    // Но если totalItems === 0, бейдж вообще не рендерится, поэтому queryByText('0') вернет null.
    // Лучше проверить, что кнопка существует, но без бейджа:
    const cartButton = screen.getByRole('button', { name: /card/i });
    // Проверим, что внутри кнопки нет элемента Badge (если бы он был отрендерен с 0)
    // В текущем коде: {totalItems > 0 && <Badge>}, значит при 0 бейдж не рендерится.
    // Поэтому проверим, что кнопка есть, и что в ней нет текста "0" как дочернего элемента Badge.
    // Проще всего: если totalItems = 0, Badge не рендерится, и `getByText('0')` внутри Badge не найдет ничего.
    // Проверим, что кнопка содержит иконку, но не содержит Badge с числом.
    expect(cartButton).toBeInTheDocument();
    // getByRole('button') уже нашел кнопку. Проверим, что внутри нет Badge с числом.
    // В текущем коде Badge рендерится внутри Button, но только если totalItems > 0.
    // Поэтому, если totalItems = 0, Badge не будет дочерним элементом Button в DOM.
    // queryByText('0') ищет *всюду* на странице. Нужно искать внутри Button.
    // screen.getByRole('button', { name: /card/i }).queryByText('0') - так нельзя.
    // Нужно получить элемент кнопки и проверить его содержимое.
    const badgeElement = screen.queryByText(mockCartItems.length.toString()); // Пытаемся найти бейдж с числом (например, "3")
    // При totalItems = 0, badgeElement будет null, так как Badge не рендерится.
    expect(badgeElement).not.toBeInTheDocument(); // Убедимся, что бейдж не отрендерился при totalItems=0
  });

  it('opens the drawer when the cart button is clicked', () => {
    renderHeader();

    // Находим кнопку корзины
    const cartButton = screen.getByRole('button', { name: /card/i });

    // Проверяем, что drawer изначально закрыт (содержимое CartBag/EmptyCart не видно)
    expect(screen.queryByTestId('mock-cart-bag')).not.toBeInTheDocument(); // Мок-компонент CartBag не должен быть виден
    expect(screen.queryByText('You cart is empty!')).not.toBeInTheDocument(); // Сообщение о пустой корзине не видно
    expect(screen.queryByAltText('Корзина пуста')).not.toBeInTheDocument(); // Изображение пустой корзины не видно

    // Кликаем по кнопке корзины
    fireEvent.click(cartButton);

    // Проверяем, что drawer открылся (содержимое должно появиться)
    // Для проверки открытия Drawer в RTL часто используют `getByText` или `getByRole` того, что внутри него.
    // В нашем случае, это либо сообщение "empty", либо CartBag.
    // Так как начальный cartItems пустой, должно открыться сообщение о пустой корзине.
    expect(screen.getByText('You cart is empty!')).toBeInTheDocument(); // Сообщение о пустой корзине теперь видно
    expect(screen.getByAltText('Корзина пуста')).toBeInTheDocument(); // Изображение пустой корзины видно
    expect(screen.getByRole('img', { name: 'Корзина пуста' })).toHaveAttribute('src', 'mocked-cart-empty-image-path.png'); // Проверка src мок-изображения
  });

  it('displays empty cart message and image inside the drawer when cart is empty', () => {
    renderHeader([], 0, 0); // Рендерим с пустой корзиной

    // Открываем drawer (в тесте выше показано, как)
    const cartButton = screen.getByRole('button', { name: /card/i });
    fireEvent.click(cartButton);

    // Проверяем, что внутри drawer отображается сообщение и изображение
    expect(screen.getByText('You cart is empty!')).toBeInTheDocument();
    expect(screen.getByAltText('Корзина пуста')).toBeInTheDocument();
    expect(screen.getByRole('img', { name: 'Корзина пуста' })).toHaveAttribute('src', 'mocked-cart-empty-image-path.png');
  });

  it('displays CartBag component inside the drawer when cart has items', () => {
    renderHeader(mockCartItems, mockCartItems.length, mockTotalCost); // Рендерим с товарами в корзине

    // Открываем drawer
    const cartButton = screen.getByRole('button', { name: /card/i });
    fireEvent.click(cartButton);

    // Проверяем, что внутри drawer отображается компонент CartBag (в данном случае его мок)
    expect(screen.getByTestId('mock-cart-bag')).toBeInTheDocument();
    // Проверяем, что мок-компонент получил правильные пропсы
    expect(screen.getByText(`Mock CartBag: ${mockCartItems.length} items, Total: $${mockTotalCost}`)).toBeInTheDocument();
  });

  // Тест для проверки вызова функций update и remove через CartBag (опционально, зависит от архитектуры)
  // Если Header напрямую не управляет вызовами, а передает пропсы в CartBag, который их вызывает,
  // то основная проверка происходит в тестах CartBag.
  // Но можно проверить, что Header передает *какие-то* функции.
  it('passes update and remove functions to CartBag', () => {
    // Этот тест в основном проверяет, что функции передаются в CartBag.
    // Реальную логику вызова этих функций лучше тестировать в CartBag.test.tsx.
    // Здесь можно просто проверить, что CartBag получает функции (если вы можете как-то проверить пропсы мок-компонента).
    // Это сложнее без специального мок-объекта, который отслеживает полученные пропсы.
    // Поэтому часто тестируют только рендеринг и передачу *в принципе*.
    // В данном случае, мок CartBag не позволяет легко проверить переданные функции.
    // Тест в CartBag будет проверять, были ли вызваны *его* пропсы-функции.
    // Header тестирует *свой* UI и *факт* передачи пропсов.
    // Проверим, что при наличии товаров рендерится CartBag.
    renderHeader(mockCartItems, mockCartItems.length, mockTotalCost);
    const cartButton = screen.getByRole('button', { name: /card/i });
    fireEvent.click(cartButton);

    expect(screen.getByTestId('mock-cart-bag')).toBeInTheDocument();
    // Сами функции mockUpdateCartItemQuantity и mockRemoveCartItem будут протестированы в CartBag.test.tsx,
    // когда CartBag их вызывает.
  });
});